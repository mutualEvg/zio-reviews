package com.nathan.reviewboard.services

import com.nathan.reviewboard.domain.data.{User, UserToken}
import com.nathan.reviewboard.domain.errors.UnauthorizedException
import com.nathan.reviewboard.repositories.{RecoveryTokensRepository, UserRepository}
import zio.*

import java.security.SecureRandom
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec

trait UserService {
  def registerUser(email: String, password: String): Task[User]
  def verifyPassword(email: String, password: String): Task[Boolean]

  def updatePassword(email: String, oldPassword: String, newPassword: String): Task[User]
  def deleteUser(email: String, password: String): Task[User]

  // JWT
  def generateToken(email: String, password: String): Task[Option[UserToken]]

  // password recovery flow
  def sendPasswordRecoveryToken(email: String): Task[Unit]
  def recoverPasswordFromToken(email: String, token: String, newPassword: String): Task[Boolean]

}

class UserServiceLive private (
    jwtService: JWTService,
    emailService: EmailService,
    userRepo: UserRepository,
    tokenRepo: RecoveryTokensRepository
) extends UserService {
  // registerUser
  override def registerUser(email: String, password: String): Task[User] =
    userRepo.create(
      User(
        id = -1L, // generated by the DB
        email = email,
        hashedPassword = UserServiceLive.Hasher.generateHash(password)
      )
    )

  // verifyPassword
  override def verifyPassword(email: String, password: String): Task[Boolean] =
    for {
      existingUser <- userRepo.getByEmail(email)
      result <- existingUser match {
        case Some(user) =>
          ZIO
            .attempt(UserServiceLive.Hasher.validateHash(password, user.hashedPassword))
            .orElseSucceed(false)
        case None => ZIO.succeed(false)
      }
    } yield result

  override def updatePassword(email: String, oldPassword: String, newPassword: String): Task[User] =
    for {
      existingUser <- userRepo
        .getByEmail(email)
        .someOrFail(UnauthorizedException(s"User $email: doesn't exist"))
      verified <- ZIO.attempt(
        UserServiceLive.Hasher.validateHash(oldPassword, existingUser.hashedPassword)
      )
      updatedUser <- userRepo
        .update(
          existingUser.id,
          user => user.copy(hashedPassword = UserServiceLive.Hasher.generateHash(newPassword))
        )
        .when(verified)
        .someOrFail(new RuntimeException(s"Could not update password for $email"))
    } yield updatedUser

  override def deleteUser(email: String, password: String): Task[User] =
    for {
      existingUser <- userRepo
        .getByEmail(email)
        .someOrFail(UnauthorizedException(s"User $email: doesn't exist"))
      verified <- ZIO.attempt(
        UserServiceLive.Hasher.validateHash(password, existingUser.hashedPassword)
      )
      updatedUser <- userRepo
        .delete(existingUser.id)
        .when(verified)
        .someOrFail(new RuntimeException(s"Could not update password for $email"))
    } yield updatedUser

  // generateToken
  override def generateToken(email: String, password: String): Task[Option[UserToken]] =
    for {
      existingUser <- userRepo
        .getByEmail(email)
        .someOrFail(UnauthorizedException(s"User $email: doesn't exist"))
      verified <- ZIO.attempt(
        UserServiceLive.Hasher.validateHash(password, existingUser.hashedPassword)
      )
      maybeToken <- jwtService.createToken(existingUser).when(verified)
    } yield maybeToken

  // password recovery flow
  /*override def sendPasswordRecoveryToken(email: String): Task[Unit] =
    tokenRepo.getToken(email).flatMap {
      case Some(token) => emailService.sendPasswordRecoveryEmail(email, token)
      case None        => ZIO.unit
    }*/

  //FIXME REMOVE LOGGING
  // Corrected implementation for your repository structure
  // For sending a recovery token, use createOrRefreshToken
  override def sendPasswordRecoveryToken(email: String): Task[Unit] =
    for {
      _ <- ZIO.logInfo(s"Generating password recovery token for: $email")

      tokenOpt <- tokenRepo.createOrRefreshToken(email).tap {
        tokenOpt =>
          ZIO.logInfo(s"Token created: ${tokenOpt.isDefined} for $email")
      }

      _ <- tokenOpt match {
        case Some(token) =>
          ZIO.logInfo(s"Sending recovery email with token to: $email") *>
            emailService
              .sendPasswordRecoveryEmail(email, token)
              .tap(
                _ => ZIO.logInfo(s"Recovery email sent to: $email")
              )
        case None =>
          ZIO.logWarning(s"No token generated for: $email - user likely doesn't exist") *>
            ZIO.unit
      }
    } yield ()

  //FIXME REMOVE LOGGING
  // For recovery, use getExistingToken for logging/debugging only
  override def recoverPasswordFromToken(
      email: String,
      token: String,
      newPassword: String
  ): Task[Boolean] =
    for {
      _ <- ZIO.logInfo(s"Starting password recovery for: $email")

      // Only for debugging
      existingToken <- tokenRepo.getExistingToken(email).tap {
        tokenOpt =>
          ZIO.logInfo(s"Existing token found: ${tokenOpt.isDefined} for $email")
      }
      _ <- ZIO.logInfo(s"Found token: ${existingToken.getOrElse("none")} for email: $email")
      _ <- ZIO.logInfo(s"Requested token: $token")
      _ <- ZIO.logInfo(s"Token match: ${existingToken.contains(token)}")

      // Get the user
      existingUser <- userRepo
        .getByEmail(email)
        .tap(
          userOpt => ZIO.logInfo(s"User exists: ${userOpt.isDefined} for $email")
        )
        .someOrFail(new RuntimeException("Non-existent user"))
      _ <- ZIO.logInfo(s"Found user with ID: ${existingUser.id}")

      // Use checkToken which should not create a new token
      tokenIsValid <- tokenRepo
        .checkToken(email, token)
        .tap(
          valid => ZIO.logInfo(s"Token validation result: $valid for $email")
        )

      // Log decision
      _ <- ZIO.when(tokenIsValid)(
        ZIO.logInfo(s"Token is valid, will update password for: $email")
      )
      _ <- ZIO.when(!tokenIsValid)(
        ZIO.logWarning(s"Token is invalid, won't update password for: $email")
      )

      // Update if valid
      updateOpt <- ZIO.when(tokenIsValid) {
        userRepo
          .update(
            existingUser.id,
            user => user.copy(hashedPassword = UserServiceLive.Hasher.generateHash(newPassword))
          )
          .tap(
            _ => ZIO.logInfo(s"Password updated successfully for: $email")
          )
      }

      result = updateOpt.isDefined
      _ <- ZIO.logInfo(s"Password recovery result for $email: $result")
    } yield result

}

object UserServiceLive {
  val layer = ZLayer {
    for {
      jwtService   <- ZIO.service[JWTService]
      emailService <- ZIO.service[EmailService]
      userRepo     <- ZIO.service[UserRepository]
      tokenRepo    <- ZIO.service[RecoveryTokensRepository]
    } yield new UserServiceLive(jwtService, emailService, userRepo, tokenRepo)
  }

  object Hasher {
    // string + salt + nIterations PBKDF2
    private val PBKDF2_ALGORITHM: String = "PBKDF2WithHmacSHA512"
    private val PBKDF2_ITERATIONS: Int   = 1000
    private val SALT_BYTE_SIZE: Int      = 24
    private val HASH_BYTE_SIZE: Int      = 24
    private val skf: SecretKeyFactory    = SecretKeyFactory.getInstance(PBKDF2_ALGORITHM)

    private def pbkdf2(
        message: Array[Char],
        salt: Array[Byte],
        iterations: Int,
        nBytes: Int
    ): Array[Byte] = {
      val keySpec = new PBEKeySpec(message, salt, iterations, nBytes * 8)
      skf.generateSecret(keySpec).getEncoded()
    }

    private def toHex(array: Array[Byte]): String =
      array
        .map(
          b => "%02X".format(b)
        )
        .mkString

    private def fromHex(string: String): Array[Byte] =
      string.sliding(2, 2).toArray.map {
        hexValue =>
          Integer.parseInt(hexValue, 16).toByte
      }

    // a(i) ^ b(i) for every i
    private def compareBytes(a: Array[Byte], b: Array[Byte]): Boolean = {
      val range = 0 until math.min(a.length, b.length)
      val diff = range.foldLeft(a.length ^ b.length) {
        case (acc, i) => acc | (a(i) ^ b(i))
      }
      diff == 0
    }

    def generateHash(string: String): String = {
      val rng: SecureRandom = new SecureRandom()
      val salt: Array[Byte] = Array.ofDim[Byte](SALT_BYTE_SIZE)
      rng.nextBytes(salt) // creates 24 random bytes
      val hashBytes = pbkdf2(string.toCharArray(), salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE)
      s"$PBKDF2_ITERATIONS:${toHex(salt)}:${toHex(hashBytes)}"
    }

    def validateHash(string: String, hash: String): Boolean = {
      val hashSegments = hash.split(":")
      val nIterations  = hashSegments(0).toInt
      val salt         = fromHex(hashSegments(1))
      val validHash    = fromHex(hashSegments(2))
      val testHash     = pbkdf2(string.toCharArray(), salt, nIterations, HASH_BYTE_SIZE)
      compareBytes(testHash, validHash)
    }

  }
}
object UserServiceDemo {
  def main(args: Array[String]) =
    println(UserServiceLive.Hasher.generateHash("ezra"))
    println(
      UserServiceLive.Hasher.validateHash(
        "ezra",
        "1000:D56F98C6193A3CB77E4549CE2CF3C996FCDB69831FC59F64:652ECB3401A283A8F4D5C21389480DCE99D19AA3C89EA380"
      )
    )
}
